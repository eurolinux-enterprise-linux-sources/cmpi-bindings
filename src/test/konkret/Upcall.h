/*
**==============================================================================
**
** CAUTION: This file generated by KonkretCMPI. Please do not edit.
**
**==============================================================================
*/

#ifndef _konkrete_Upcall_h
#define _konkrete_Upcall_h

#include <konkret/konkret.h>

/*
**==============================================================================
**
** struct UpcallRef 
**
**==============================================================================
*/

/* classname=KC_Upcall */
typedef struct _UpcallRef
{
    KBase __base;
    /* KC_Upcall features */
    const KString Id;
}
UpcallRef;

static const unsigned char __UpcallRef_sig[] =
{
    0x09,0x4b,0x43,0x5f,0x55,0x70,0x63,0x61,0x6c,0x6c,0x00,0x01,0x4c,0x02,0x49,
    0x64,0x00,
};

KINLINE void UpcallRef_Init(
    UpcallRef* self,
    const CMPIBroker* cb,
    const char* ns)
{
    const unsigned char* sig = __UpcallRef_sig;
    KBase_Init(&self->__base, cb, sizeof(*self), sig, ns);
}

KINLINE CMPIStatus UpcallRef_InitFromInstance(
    UpcallRef* self,
    const CMPIBroker* cb,
    const CMPIInstance* x)
{
    UpcallRef_Init(self, cb, NULL);
    return KBase_FromInstance(&self->__base, x);
}

KINLINE CMPIStatus UpcallRef_InitFromObjectPath(
    UpcallRef* self,
    const CMPIBroker* cb,
    const CMPIObjectPath* x)
{
    UpcallRef_Init(self, cb, NULL);
    return KBase_FromObjectPath(&self->__base, x);
}

KINLINE void UpcallRef_Print(
    const UpcallRef* self,
    FILE* os)
{
    KBase_Print(os, &self->__base, 'r');
}

KINLINE CMPIInstance* UpcallRef_ToInstance(
    const UpcallRef* self,
    CMPIStatus* status)
{
    return KBase_ToInstance(&self->__base, status);
}

KINLINE CMPIObjectPath* UpcallRef_ToObjectPath(
    const UpcallRef* self,
    CMPIStatus* status)
{
    return KBase_ToObjectPath(&self->__base, status);
}

KINLINE const char* UpcallRef_NameSpace(
    UpcallRef* self)
{
    if (self && self->__base.magic == KMAGIC)
        return self->__base.ns ? KChars(self->__base.ns) : NULL;
    return NULL;
}

KINLINE void UpcallRef_SetString_Id(
    UpcallRef* self,
    CMPIString* x)
{
    if (self && self->__base.magic == KMAGIC)
    {
        KString* field = (KString*)&self->Id;
        KString_SetString(field, x);
    }
}

KINLINE void UpcallRef_Set_Id(
    UpcallRef* self,
    const char* s)
{
    if (self && self->__base.magic == KMAGIC)
    {
        KString* field = (KString*)&self->Id;
        KString_Set(field, self->__base.cb, s);
    }
}

KINLINE void UpcallRef_Null_Id(
    UpcallRef* self)
{
    if (self && self->__base.magic == KMAGIC)
    {
        KString* field = (KString*)&self->Id;
        KString_Null(field);
    }
}

KINLINE void UpcallRef_Clr_Id(
    UpcallRef* self)
{
    if (self && self->__base.magic == KMAGIC)
    {
        KString* field = (KString*)&self->Id;
        KString_Clr(field);
    }
}

/*
**==============================================================================
**
** struct Upcall 
**
**==============================================================================
*/

/* classname=KC_Upcall */
typedef struct _Upcall
{
    KBase __base;
    /* KC_Upcall features */
    const KString Id;
}
Upcall;

static const unsigned char __Upcall_sig[] =
{
    0x09,0x4b,0x43,0x5f,0x55,0x70,0x63,0x61,0x6c,0x6c,0x00,0x01,0x4c,0x02,0x49,
    0x64,0x00,
};

KINLINE void Upcall_Init(
    Upcall* self,
    const CMPIBroker* cb,
    const char* ns)
{
    const unsigned char* sig = __Upcall_sig;
    KBase_Init(&self->__base, cb, sizeof(*self), sig, ns);
}

KINLINE CMPIStatus Upcall_InitFromInstance(
    Upcall* self,
    const CMPIBroker* cb,
    const CMPIInstance* x)
{
    Upcall_Init(self, cb, NULL);
    return KBase_FromInstance(&self->__base, x);
}

KINLINE CMPIStatus Upcall_InitFromObjectPath(
    Upcall* self,
    const CMPIBroker* cb,
    const CMPIObjectPath* x)
{
    Upcall_Init(self, cb, NULL);
    return KBase_FromObjectPath(&self->__base, x);
}

KINLINE void Upcall_Print(
    const Upcall* self,
    FILE* os)
{
    KBase_Print(os, &self->__base, 'i');
}

KINLINE CMPIInstance* Upcall_ToInstance(
    const Upcall* self,
    CMPIStatus* status)
{
    return KBase_ToInstance(&self->__base, status);
}

KINLINE CMPIObjectPath* Upcall_ToObjectPath(
    const Upcall* self,
    CMPIStatus* status)
{
    return KBase_ToObjectPath(&self->__base, status);
}

KINLINE const char* Upcall_NameSpace(
    Upcall* self)
{
    if (self && self->__base.magic == KMAGIC)
        return self->__base.ns ? KChars(self->__base.ns) : NULL;
    return NULL;
}

KINLINE void Upcall_SetString_Id(
    Upcall* self,
    CMPIString* x)
{
    if (self && self->__base.magic == KMAGIC)
    {
        KString* field = (KString*)&self->Id;
        KString_SetString(field, x);
    }
}

KINLINE void Upcall_Set_Id(
    Upcall* self,
    const char* s)
{
    if (self && self->__base.magic == KMAGIC)
    {
        KString* field = (KString*)&self->Id;
        KString_Set(field, self->__base.cb, s);
    }
}

KINLINE void Upcall_Null_Id(
    Upcall* self)
{
    if (self && self->__base.magic == KMAGIC)
    {
        KString* field = (KString*)&self->Id;
        KString_Null(field);
    }
}

KINLINE void Upcall_Clr_Id(
    Upcall* self)
{
    if (self && self->__base.magic == KMAGIC)
    {
        KString* field = (KString*)&self->Id;
        KString_Clr(field);
    }
}

/*
**==============================================================================
**
** Upcall methods
**
**==============================================================================
*/

KINLINE CMPIStatus Upcall_DispatchMethod(
    const CMPIBroker* cb,
    CMPIMethodMI* mi,
    const CMPIContext* cc,
    const CMPIResult* cr,
    const CMPIObjectPath* cop,
    const char* meth,
    const CMPIArgs* in,
    CMPIArgs* out)
{
    UpcallRef self;

    KReturnIf(UpcallRef_InitFromObjectPath(&self, cb, cop));


    KReturn(ERR_METHOD_NOT_FOUND);
}

#define Upcall_ClassName "KC_Upcall"

#endif /* _konkrete_Upcall_h */
